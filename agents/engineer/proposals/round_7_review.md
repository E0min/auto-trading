# Round 7 교차 리뷰 -- Engineer

**작성자**: Senior Systems Engineer
**작성일**: 2026-02-16
**리뷰 대상**: Trader 제안서 (round_7.md), UI 제안서 (round_7.md)

---

## Trader 제안서 리뷰

### A-1. hysteresisMinCandles 3 -> 15

- **판정**: ⚠️ 조건부 동의
- **사유**:
  Trader의 분석은 정확하다. `hysteresisMinCandles: 3`은 1분 캔들 기반에서 3분에 해당하며, 18개 전략의 최소 유효 매매 사이클(10~120분)에 비해 지나치게 짧다. 이 부분의 문제 인식은 완전히 동의한다.

  그러나 기본값 15(=15분)는 내 제안인 8(=8분)에 비해 상당히 보수적이다. 다음 관점에서 절충이 필요하다:

  **15가 과도할 수 있는 이유**:
  - 15분은 실제 시장 레짐 변화(flash crash, 대형 뉴스) 감지를 지나치게 지연시킬 수 있다. 2024년 8월 5일 BTC 급락 같은 이벤트에서 15분 지연은 상당한 손실을 초래할 수 있다
  - 레짐 전환 쿨다운(A-2)과 유예기간(B-1)이 함께 도입되므로, 히스테리시스 자체는 "확인용"이지 "유일한 방어선"이 아니다. 즉 히스테리시스 + 쿨다운 + 유예기간의 **삼중 보호**가 적용되므로, 히스테리시스 하나에 과도한 지연을 부여할 필요가 없다
  - 8분이면 1-3분짜리 노이즈 스파이크는 완전히 필터링되면서도, 5분 이상 지속되는 실제 구조적 변화는 8분 안에 감지된다

  **8이면 충분한 이유**:
  - 삼중 보호 체계: hysteresis 8분 + cooldown 5분 + grace period 3~15분 = 최소 16분~28분의 버퍼
  - RegimeOptimizer가 [5, 15] 범위에서 자동 탐색하면, 시장 상황에 따라 최적값을 찾을 수 있다
  - 기본값은 "안전한 출발점"이면 충분하고, 최적화로 수렴시키는 것이 더 과학적

  **권장**: 기본값 **10**으로 절충. 옵티마이저 범위는 Trader 제안의 [10, 30]이 아닌 **[5, 15]**를 권장 (아래 A-4 항목 참조).

### A-2. 레짐 전환 쿨다운 도입 (regimeTransitionCooldownMs: 300,000)

- **판정**: ✅ 동의
- **사유**:
  내 제안(A-2)과 동일한 메커니즘이며, 같은 5분 기본값을 제안하고 있다. 구현 방식도 timestamp 비교 기반으로 동일하다. 타이머(`setTimeout`)를 사용하지 않고 `Date.now()` 비교만으로 구현하면 타이머 누수 위험이 제로이며, 이는 내 제안의 핵심 원칙과 일치한다.

  Trader의 의사코드에서 한 가지 주의점: 쿨다운 중에도 `_pendingCount`를 축적하는 설계는 올바르다. 쿨다운 종료 시점에서 이미 충분한 캔들이 쌓여 있으면 즉시 전환할 수 있어, 쿨다운으로 인한 불필요한 추가 지연을 방지한다.

### A-3. 히스테리시스 가중치 0.10 -> 0.15

- **판정**: ⚠️ 조건부 동의
- **사유**:
  가중치 상향의 방향성은 동의하지만, **정적 가중치 변경보다는 내 제안(A-3)의 동적 decay 방식이 더 우수하다**.

  정적 0.15의 문제:
  - 모든 상황에서 동일한 관성을 부여하므로, 레짐이 장기간 안정된 후의 전환과 방금 전환된 직후의 전환이 동일한 저항을 받는다
  - 실제로는 전환 직후에 ping-pong을 가장 강하게 억제해야 하고, 시간이 경과하면 관성 보너스를 줄여야 한다

  그러나 동적 decay는 P2(개선) 우선순위이므로, R7 스코프에서는 정적 0.15도 수용 가능하다. 단, 나머지 5개 팩터의 가중치를 각각 0.01씩 줄이는 방식은 합계 1.0을 유지하므로 문제없다.

  **권장**: R7에서는 정적 0.15를 적용하되, R8에서 동적 decay를 도입하는 것으로 로드맵에 기록.

### A-4. RegimeOptimizer 파라미터 범위 [10, 30]

- **판정**: ❌ 반대
- **사유**:
  `hysteresisMinCandles` 옵티마이저 범위를 [10, 30]으로 설정하면 **과적합(overfitting) 위험**이 높다.

  **문제점**:
  1. **범위 하한 10 = 최소 10분**: 빠른 시장 반응이 불가능. 옵티마이저가 10 미만으로 내릴 수 없으므로, 실제로 5~8분이 최적인 시장 환경에서 차선책만 선택 가능
  2. **범위 상한 30 = 최소 30분**: 30분 히스테리시스 + 5분 쿨다운 = 35분 최소 전환 시간. 여기에 유예기간까지 합치면 40~50분. 이는 암호화폐 시장의 구조적 레짐 변화 속도에 비해 과도하게 느리다
  3. **과적합 경로**: 옵티마이저가 역사 데이터에서 "전환이 적을수록 수익이 높다"는 편향을 학습하여 극단적으로 높은 값을 선택할 수 있다. 이는 "전환하지 않는 것이 최선"이라는 결론으로 귀결되며, 실질적으로 레짐 기반 라우팅 시스템 자체를 무력화
  4. **탐색 공간 효율**: [10, 30]은 20개 이산값을 탐색하는데, 대부분의 값이 "과도하게 보수적" 영역에 몰려 있어 탐색 효율이 낮다

  **대안**: **[5, 15]**를 권장.
  - 하한 5분: 급변 시장에서도 최소한의 반응 속도 보장
  - 상한 15분: 삼중 보호 체계에서 충분한 안정성
  - 기본값 10이 범위 중앙에 위치하여 양방향 탐색이 가능
  - 쿨다운과 유예기간이 추가 보호를 제공하므로 히스테리시스 단독으로 극단값을 가질 필요 없음

  **`regimeTransitionCooldownMs` 범위**도 재검토 필요:
  - Trader 제안: [120,000, 900,000] (2분~15분)
  - 내 제안: [120,000, 600,000] (2분~10분)
  - 15분 쿨다운은 히스테리시스와 합산하면 30분 이상이 되어 과도. **[120,000, 600,000]**을 권장.

### B-1. 전략별 gracePeriod 차별화 (카테고리별)

- **판정**: ⚠️ 조건부 동의
- **사유**:
  전략별 유예기간 차별화의 트레이딩 논리는 합리적이다. price-action 전략이 indicator-light보다 긴 매매 사이클을 가진다는 분석은 정확하다.

  **시스템 안정성 관점의 우려**:

  1. **복잡도 증가**: 17개 전략 파일 각각에 `gracePeriodMs` 메타데이터를 추가하는 것은 관리 부담. 특히 전략이 추가/삭제될 때마다 gracePeriod를 검토해야 하는 운영 부담이 생긴다
  2. **테스트 부담**: 전략별로 다른 유예기간 = 전략별 테스트 시나리오 증가. 3개 카테고리 x 5개 레짐 전환 방향 = 15개 기본 시나리오
  3. **디버깅 어려움**: 프로덕션에서 "이 전략은 왜 아직 활성인데 저 전략은 비활성인가?"를 파악하려면 각 전략의 gracePeriod를 확인해야 함

  **그러나 이점도 분명**:
  - Grid(30초 사이클)에 10분 유예기간은 불필요한 자원 낭비
  - Breakout(30분~2시간 사이클)에 3분 유예기간은 불충분

  **권장**: R7에서는 **2단계 접근**을 제안.
  - Phase 1: 전체 통일 기본값 (내 제안의 180,000ms = 3분) + StrategyRouter에서 설정 가능
  - Phase 2 (검증 후): 전략 메타데이터에 `gracePeriodMs`를 추가하여 개별 오버라이드
  - Phase 1에서 실제 운영 데이터를 축적한 후, 어떤 전략에 얼마나 긴 유예가 필요한지 데이터 기반으로 결정

  단, Trader가 카테고리별로 이미 합리적인 값을 제시했으므로, **Phase 1을 건너뛰고 바로 카테고리별 적용도 수용 가능**하다. 핵심은 `_getDefaultGracePeriod()` 폴백 로직이 명확히 구현되어야 한다는 것.

### B-2. 유예기간 만료 타이머 (setInterval 10초)

- **판정**: ❌ 반대
- **사유**:
  Trader는 `setInterval(() => this._checkGraceExpiry(), 10000)`으로 10초마다 모든 전략을 폴링하는 방식을 제안했다. 이는 **비효율적이고 타이머 누수 위험**이 있다.

  **문제점**:
  1. **불필요한 폴링**: 유예기간이 정확한 timestamp로 관리되므로, 각 전략별로 `setTimeout`을 하나씩 걸어 정확한 만료 시점에 콜백을 실행하는 것이 더 효율적이다
  2. **10초 오차**: setInterval 방식은 유예 만료와 실제 deactivate 사이에 최대 10초 오차가 발생. 정밀한 시스템에서 불필요한 비결정성
  3. **타이머 누수**: `start()`에서 생성한 `setInterval`이 `stop()`에서 제대로 정리되지 않으면 누수. 내 제안처럼 전략별 `setTimeout` + `unref()` + `stop()`에서 전체 정리가 더 안전
  4. **_inGracePeriod 직접 접근**: `strategy._inGracePeriod`를 외부에서 직접 읽는 것은 캡슐화 위반. `strategy.isInGracePeriod()` 메서드를 통해야 함

  **대안**: 내 제안(B-1)의 전략별 `setTimeout` + `_gracePeriods` Map 방식을 사용. 각 유예기간에 대해:
  - `setTimeout`으로 정확한 만료 시점에 콜백
  - `timer.unref()`로 프로세스 종료 차단 방지
  - `stop()`에서 `_gracePeriods` 전체 순회하며 `clearTimeout`
  - 콜백 내에서 `_gracePeriods.delete(name)` 선행 실행으로 재진입 방지

### B-3. 유예기간 중 레짐 복귀 시 취소

- **판정**: ✅ 동의
- **사유**:
  유예 중 레짐이 다시 호환되면 즉시 유예를 취소하고 정상 활성으로 복귀하는 것은 필수적이다. 불필요하게 전략을 비활성화하는 것을 방지하여 수익 기회를 보존한다.

  `cancelGracePeriod()` 메서드의 구현도 단순하여 버그 위험이 낮다. 단, 내 제안에서 강조한 것처럼 유예 취소 시 반드시 타이머(`clearTimeout`)를 정리해야 한다. Trader의 `cancelGracePeriod`는 `_inGracePeriod`와 `_graceDeadline`만 초기화하고 **타이머 정리가 누락**되어 있다 -- 이는 B-2에서 setInterval을 사용하기 때문이지만, setTimeout 방식으로 변경하면 이 문제는 자연스럽게 해결된다.

### B-1/B-3 전반: strategyBase.js vs strategyRouter.js 상태 소유권

- **판정**: ⚠️ 조건부 동의
- **사유**:
  Trader는 `strategyBase.js`에 `_inGracePeriod`, `_graceDeadline`, `enterGracePeriod()`, `isInGracePeriod()`, `cancelGracePeriod()`를 추가하여 **전략 자체가 유예 상태를 관리**하도록 제안했다.

  내 제안은 `strategyRouter.js`의 `_gracePeriods` Map에서 **라우터가 유예 상태를 중앙 관리**하는 방식이다.

  **비교**:
  | 관점 | Trader (전략 소유) | Engineer (라우터 소유) |
  |------|-------------------|----------------------|
  | 상태 일관성 | 분산 상태 -- 전략과 라우터 간 동기화 필요 | 단일 진실 소스(SSOT) |
  | 캡슐화 | 전략이 자기 상태를 안다 (OOP 관점 양호) | 전략은 유예를 모름 (SRP 관점 양호) |
  | 타이머 관리 | 각 전략이 자체 타이머? 누가 정리? | 라우터가 모든 타이머 소유/정리 |
  | 테스트 용이성 | 전략 단위 테스트 가능 | 라우터 단위 테스트로 충분 |
  | 기존 패턴 유사성 | 새로운 패턴 | `_gracefulDisabledStrategies` 패턴과 유사 |

  **권장**: **라우터 소유 방식(내 제안)**이 시스템 안정성 관점에서 우월하다. 이유:
  1. 타이머 lifecycle이 라우터의 `start()`/`stop()`에 명확히 종속
  2. `_gracePeriods` Map 하나로 모든 유예 상태를 조회/관리 가능
  3. `botService._gracefulDisabledStrategies`와 동일한 패턴으로 코드 일관성 확보
  4. 전략 서브클래스 18개를 수정할 필요 없음 (strategyBase.js만 수정)

  단, `strategyBase.js`에 `isInGracePeriod()` 같은 조회 메서드를 추가하는 것은 프론트엔드 상태 노출 목적으로 유용하므로, 라우터가 유예 진입 시 `strategy.setGracePeriod(true/false)`를 호출하여 전략에도 플래그를 전달하는 **하이브리드 방식**이 적합하다.

### 전략별 최소 유효 매매 사이클 분석 (표)

- **판정**: ✅ 동의
- **사유**:
  Trader가 제시한 18개 전략의 cooldownMs + 최소 유효 사이클 분석은 매우 유용하다. 이 데이터는 유예기간 기본값 설정의 근거로 직접 활용 가능하다. 특히 QuietRangeScalp(5~15분)과 Breakout(30~120분)의 극단적 차이는 카테고리별 gracePeriod 차별화의 필요성을 잘 보여준다.

### 포지션 고아화 위험 분석

- **판정**: ✅ 동의
- **사유**:
  `strategyRouter._routeStrategies()`에서 `strategy.deactivate()`를 직접 호출하면서 `botService.disableStrategy()`를 경유하지 않는 문제는 정확한 지적이다. 이로 인해 소프트웨어 기반 SL을 사용하는 전략의 열린 포지션이 관리 사각지대에 놓일 수 있다. 유예기간 도입으로 이 문제의 시간적 여유가 확보되며, 유예기간 동안 SL/TP 시그널이 계속 처리되므로 위험이 크게 감소한다.

---

## UI 제안서 리뷰

### P0-1. 전략 상태 3-way 배지 (active / grace / inactive)

- **판정**: ✅ 동의
- **사유**:
  유예기간 상태를 사용자에게 전달하는 것은 필수적이다. amber 색상 + pulsing dot + 카운트다운은 직관적이다.

  타입 확장에서 `routerState?: 'active' | 'grace' | 'inactive'` 추가는 적절하다. 다만 이 필드는 **백엔드 API 응답에서 제공**해야 하므로, 내 제안(C-2)의 `strategyRouter.getStatus()` 확장이 선행되어야 한다.

  구현 순서: BE(C-2) -> FE(P0-1) -- 올바른 의존성 방향.

### P0-2. 레짐 pending/cooldown 상태 표시

- **판정**: ✅ 동의
- **사유**:
  `pendingRegime`, `pendingCount`, `hysteresisRequired` 표시는 시스템 투명성을 높인다. 운영자가 "레짐이 왜 아직 안 바뀌는지"를 이해할 수 있다.

  구현 관점에서 `_pendingRegime`, `_pendingCount`는 이미 `marketRegime.js` 내부 상태로 존재하므로, `getContext()` 확장만으로 노출 가능하다. 추가 계산이나 상태 관리가 필요 없어 성능 영향이 없다.

  `cooldownRemaining` 계산은 `Date.now() - this._lastTransitionTs`로 단순 산술이므로 CPU 부담 무시 가능.

### P0-3. Socket 이벤트 추가 (4종)

- **판정**: ⚠️ 조건부 동의
- **사유**:
  UI가 제안한 4종의 새 이벤트:
  1. `strategy:grace_started` -- 유예기간 진입
  2. `strategy:grace_expired` -- 유예기간 만료
  3. `market:regime_pending` -- 히스테리시스 대기 중 (매 캔들마다)
  4. `market:regime_cooldown` -- 쿨다운 상태

  **이벤트 1, 2**: 동의. 상태 전이 시점에만 발생하므로 빈도가 낮고 성능 영향 미미.

  **이벤트 3 (`market:regime_pending`)에 대한 우려**:
  - "각 캔들마다" emit한다고 명시. 1분 캔들 기준 분당 1회이므로 빈도 자체는 높지 않다
  - 그러나 `pending`이 아닌 상태(candidateRegime === currentRegime)에서는 emit하지 않아야 한다. pending이 아닐 때도 emit하면 불필요한 "상태 없음" 이벤트가 매분 발생
  - **보완 조건**: pending 상태가 존재할 때만 emit. `_pendingRegime !== null`인 경우에만 이벤트 발송

  **이벤트 4 (`market:regime_cooldown`)**:
  - 쿨다운 상태가 변경될 때(활성화/해제)만 emit해야 함. 매 틱마다 "쿨다운 중입니다" 이벤트를 보내면 불필요한 트래픽
  - **보완 조건**: 쿨다운 진입/해제 시점에만 emit. 또는 `getContext()` 폴링으로 대체 가능 (쿨다운 잔여 시간은 폴링이 더 적합)

  **이벤트 폭풍(event storm) 가능성**:
  - 레짐 전환이 빈번했던 문제를 해결하는 것이 R7의 목적. A-1, A-2 적용 후 전환 빈도가 시간당 1~2회로 줄면, grace 이벤트도 시간당 수회에 불과하여 이벤트 폭풍은 발생하지 않는다
  - 단, A-1/A-2 적용 전에 FE를 먼저 배포하면 기존 빈번한 전환에서 grace 이벤트가 대량 발생할 수 있다. **배포 순서**: BE(A-1, A-2) -> BE(B-1~B-4) -> FE(P0-1~P0-3)

### P1-1. 유예기간 카운트다운 타이머 (setInterval 1초)

- **판정**: ⚠️ 조건부 동의
- **사유**:
  `graceExpiresAt`으로부터 클라이언트 측 카운트다운은 UX 관점에서 우수하다. 그러나:

  **메모리/성능 보완점**:
  1. `setInterval` 1초마다 갱신은 React 리렌더링을 유발한다. 유예 중인 전략이 여러 개(예: quiet->volatile 전환 시 최대 14개 전략 비활성화)이면, 14개 카드가 매초 리렌더링된다
  2. **권장**: 카운트다운은 해당 카드가 뷰포트에 보일 때만 활성화(Intersection Observer) 또는 `requestAnimationFrame` 기반. 또는 10초 간격으로 갱신하되 남은 시간이 30초 미만일 때만 1초 간격으로 전환
  3. `setInterval` 정리(`clearInterval`)를 컴포넌트 언마운트 시 반드시 수행 -- `useEffect` cleanup으로 처리

  이 수준의 최적화는 P1이면 충분하지만, 동시 유예 전략 수가 많을 수 있으므로 구현 시 주의가 필요하다.

### P1-2. 레짐 전환 빈도 경고 인디케이터

- **판정**: ✅ 동의
- **사유**:
  전환 빈도를 시각화하는 것은 A-1/A-2 도입 후 효과를 검증하는 데 필수적이다. `segments` 배열을 순회하여 최근 1시간 내 전환 수를 카운트하는 로직은 단순하고 성능 부담이 없다.

  경고 수준(3회 이하 = 안정, 4~6회 = 빈번, 7회 이상 = 과다)은 A-1/A-2 적용 후 예상 빈도(시간당 1~2회)에 비추어 합리적인 임계값이다.

  `_regimeHistory` 배열은 `MAX_HISTORY = 100`으로 제한되어 있으므로 메모리 무한 증가 위험은 없다.

### P1-3. 전략 상태 전이 히스토리

- **판정**: ⚠️ 조건부 동의
- **사유**:
  상태 전이 로그를 StrategyDetail 탭에 표시하는 것은 디버깅에 유용하다.

  **메모리 관련 우려**:
  - "프론트엔드에서 소켓 이벤트를 로컬 배열로 축적"이라고 명시. 이 배열이 무한히 증가하면 브라우저 메모리 문제가 발생한다
  - **보완 조건**: 최대 50~100개 엔트리로 제한. 오래된 엔트리는 FIFO로 삭제
  - 페이지 새로고침 시 히스토리가 소실되는 것은 수용 가능 (백엔드에 영구 저장할 필요 없음)
  - 또는 `RegimeTimeline`의 기존 `_regimeHistory` 데이터를 재활용하여 전략 상태를 역산하는 방식으로 별도 축적 없이 구현 가능

### P2-1. 전략-레짐 호환성 매트릭스

- **판정**: ✅ 동의 (P2 유지)
- **사유**: R7 스코프 밖으로 올바르게 분류되어 있다. 4~6시간은 R7에 포함하기에 과도.

### P2-2. 레짐 파라미터 설정 UI

- **판정**: ⚠️ 조건부 동의 (P2 유지, 추가 보안 필요)
- **사유**:
  `hysteresisMinCandles`를 슬라이더로 "1~10" 범위로 설정하도록 제안. UI 제안서에서 "잘못된 설정이 치명적일 수 있어 '고급 설정' 섹션에 경고와 함께 배치"라고 이미 인지하고 있다.

  **추가 보완**:
  1. 슬라이더 하한을 1이 아닌 **5**로 설정. `hysteresisMinCandles < 5`는 1분 캔들 기반에서 과도하게 민감
  2. 변경 시 확인 다이얼로그("이 변경은 전략 라우팅 안정성에 영향을 줍니다. 계속하시겠습니까?")
  3. 변경 로그를 RiskEvent로 기록하여 감사 추적(audit trail) 가능하도록

### P2-3. RegimeFlowMap grace 레인 추가

- **판정**: ✅ 동의 (P2 유지)
- **사유**: 3-column -> 4-column 확장은 자연스럽고 복잡도가 낮다. P0-1의 3-way 상태가 먼저 구현되면 자연스럽게 적용 가능.

### 타입 정의 확장 (types/index.ts)

- **판정**: ✅ 동의
- **사유**:
  `StrategyListItem`에 `routerState`, `graceExpiresAt`, `graceReason` 추가와 `MarketRegimeData`에 `pendingRegime`, `pendingCount`, `hysteresisRequired`, `cooldownActive`, `cooldownRemaining` 추가는 모두 백엔드 API 응답 구조와 1:1로 대응해야 한다.

  타입 정의가 선행되면 FE/BE 간 계약(contract)이 명확해져 통합 시 오류가 줄어든다.

---

## 종합 의견

### 핵심 이견 사항

| # | 항목 | Trader | Engineer | 권장 |
|---|------|--------|----------|------|
| 1 | `hysteresisMinCandles` 기본값 | 15 | 8 | **10** (절충) |
| 2 | Optimizer 범위 | [10, 30] | [5, 15] | **[5, 15]** (과적합 방지) |
| 3 | `cooldownMs` Optimizer 범위 | [120K, 900K] | [120K, 600K] | **[120K, 600K]** |
| 4 | 유예 만료 메커니즘 | setInterval 10초 폴링 | 전략별 setTimeout + unref | **setTimeout** (정밀 + 누수방지) |
| 5 | 유예 상태 소유권 | strategyBase (분산) | strategyRouter (중앙) | **라우터 중앙** + 전략에 플래그 전달 |
| 6 | 전략별 gracePeriod | 즉시 카테고리별 차별화 | 통일 기본값 우선 | **카테고리별 적용 수용** (Trader 분석이 충분) |
| 7 | `market:regime_pending` 이벤트 | 매 캔들 emit | -- | **pending 상태일 때만** emit |

### 권장 절충안

1. **hysteresisMinCandles = 10, Optimizer [5, 15]**: 8과 15의 중간. 삼중 보호 체계(히스테리시스 + 쿨다운 + 유예기간)에서 히스테리시스 단독으로 과도한 값을 가질 필요 없음. 옵티마이저가 시장 데이터 기반으로 최적값을 탐색하도록 위임.

2. **setTimeout + unref() + stop()에서 전체 정리**: setInterval 폴링 대신 전략별 정밀 타이머. 내 제안의 `_gracePeriods` Map 구조를 기반으로, Trader 제안의 카테고리별 gracePeriodMs 값을 메타데이터에서 읽어 적용.

3. **라우터 중앙 관리 + 전략 플래그 전달**: StrategyRouter의 `_gracePeriods` Map이 SSOT(단일 진실 소스). 유예 진입 시 `strategy.setGracePeriod(true)`로 전략에도 플래그를 세팅하여 `getStatus()` 응답에 포함.

4. **소켓 이벤트는 상태 전이 시점에만 emit**: `strategy:grace_started`, `strategy:grace_expired`는 전이 시 1회. `market:regime_pending`은 `_pendingRegime !== null`일 때만. `market:regime_cooldown`은 쿨다운 진입/해제 시점에만.

5. **배포 순서**: BE(A-1 + A-2) -> BE(B-1 ~ B-4 + C-1 ~ C-2) -> FE(P0-1 ~ P0-3) -> FE(P1-1 ~ P1-3). A-1/A-2 없이 유예기간만 먼저 배포하면, 빈번한 레짐 전환에서 유예 이벤트가 대량 발생할 수 있다.

6. **히스테리시스 가중치**: R7에서는 정적 0.15 적용. R8 로드맵에 동적 decay 기록.

### 합의된 사항 (이견 없음)

- 레짐 전환 쿨다운 5분 기본값 + timestamp 비교 구현
- 유예기간 중 OPEN 차단 / CLOSE 허용 패턴
- 유예 중 레짐 복귀 시 즉시 취소
- `botService.disableStrategy()`에서 grace 타이머 정리
- 전략 3-way 상태 UI (active/grace/inactive)
- 레짐 pending/cooldown 표시
- 전환 빈도 경고 인디케이터
- P2 항목들의 스코프 밖 유지

### 위험 요소 점검 총괄

| 위험 | 수준 | 방어 상태 |
|------|------|----------|
| 타이머 누수 (유예기간) | 중간 | setTimeout + unref + stop() cleanup으로 방어 |
| 레이스 컨디션 (유예 만료 vs 레짐 변경) | 중간 | _gracePeriods.delete 선행 + _running 체크로 방어 |
| 이벤트 폭풍 (소켓) | 낮음 | A-1/A-2 적용 후 전환 빈도 감소 + 조건부 emit |
| 메모리 누수 (FE 히스토리 축적) | 낮음 | 최대 엔트리 제한 (50~100개) |
| graceful disable과 grace period 충돌 | 중간 | disableStrategy에서 grace 타이머 정리 + 우선순위 규칙 |
| 과적합 (Optimizer 넓은 범위) | 중간 | [5,15] 범위 제한 + [120K, 600K] 쿨다운 범위 제한 |
